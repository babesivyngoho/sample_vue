import {
  LoaderSlot,
  VBtn,
  VCheckboxBtn,
  VIcon,
  VSelect,
  VTable,
  makeDimensionProps,
  makeFilterProps,
  makeItemsProps,
  makeLoaderProps,
  useBackgroundColor,
  useDimension,
  useFilter,
  useItems,
  useLoader
} from "./chunk-UJCK45XH.js";
import {
  IconValue,
  useDisplay,
  useLocale,
  useProxiedModel,
  useResizeObserver
} from "./chunk-5S2NW4Z6.js";
import "./chunk-2WWYPGTX.js";
import {
  clamp,
  convertToUnit,
  createRange,
  deepEqual,
  defineComponent,
  defineFunctionalComponent,
  genericComponent,
  getCurrentInstance,
  getObjectValueByPath,
  getPropertyFromItem,
  propsFactory,
  provideDefaults,
  useRender,
  useToggleScope
} from "./chunk-OQXEHRQW.js";
import {
  Fragment,
  computed,
  createTextVNode,
  createVNode,
  inject,
  mergeProps,
  onMounted,
  onUpdated,
  provide,
  ref,
  toRef,
  watch,
  watchEffect
} from "./chunk-G4DFXOZZ.js";
import "./chunk-RSJERJUL.js";

// node_modules/vuetify/lib/labs/VDataTable/VDataTable.mjs
import "C:/xampp/htdocs/sappat/sAPPat_v2_vue/node_modules/vuetify/lib/labs/VDataTable/VDataTable.css";

// node_modules/vuetify/lib/labs/VDataTable/VDataTableColumn.mjs
var VDataTableColumn = defineFunctionalComponent({
  align: {
    type: String,
    default: "start"
  },
  fixed: Boolean,
  fixedOffset: [Number, String],
  height: [Number, String],
  lastFixed: Boolean,
  noPadding: Boolean,
  tag: String,
  width: [Number, String]
}, (props, _ref) => {
  let {
    slots,
    attrs
  } = _ref;
  const Tag = props.tag ?? "td";
  return createVNode(Tag, mergeProps({
    "class": ["v-data-table__td", {
      "v-data-table-column--fixed": props.fixed,
      "v-data-table-column--last-fixed": props.lastFixed,
      "v-data-table-column--no-padding": props.noPadding
    }, `v-data-table-column--align-${props.align}`],
    "style": {
      height: convertToUnit(props.height),
      width: convertToUnit(props.width),
      left: convertToUnit(props.fixedOffset || null)
    }
  }, attrs), {
    default: () => {
      var _a;
      return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
    }
  });
});

// node_modules/vuetify/lib/labs/VDataTable/composables/headers.mjs
var makeDataTableHeaderProps = propsFactory({
  headers: {
    type: Array,
    default: () => []
  }
}, "v-data-table-header");
var VDataTableHeadersSymbol = Symbol.for("vuetify:data-table-headers");
function createHeaders(props, options) {
  const headers = ref([]);
  const columns = ref([]);
  watch(() => props.headers, () => {
    var _a, _b, _c;
    const wrapped = !props.headers.length ? [] : Array.isArray(props.headers[0]) ? props.headers : [props.headers];
    const flat = wrapped.flatMap((row, index) => row.map((column) => ({
      column,
      row: index
    })));
    const rowCount = wrapped.length;
    const defaultHeader = {
      title: "",
      sortable: false
    };
    const defaultActionHeader = {
      ...defaultHeader,
      width: 48
    };
    if ((_a = options == null ? void 0 : options.groupBy) == null ? void 0 : _a.value.length) {
      const index = flat.findIndex((_ref) => {
        let {
          column
        } = _ref;
        return column.key === "data-table-group";
      });
      if (index < 0)
        flat.unshift({
          column: {
            ...defaultHeader,
            key: "data-table-group",
            title: "Group",
            rowspan: rowCount
          },
          row: 0
        });
      else
        flat.splice(index, 1, {
          column: {
            ...defaultHeader,
            ...flat[index].column
          },
          row: flat[index].row
        });
    }
    if ((_b = options == null ? void 0 : options.showSelect) == null ? void 0 : _b.value) {
      const index = flat.findIndex((_ref2) => {
        let {
          column
        } = _ref2;
        return column.key === "data-table-select";
      });
      if (index < 0)
        flat.unshift({
          column: {
            ...defaultActionHeader,
            key: "data-table-select",
            rowspan: rowCount
          },
          row: 0
        });
      else
        flat.splice(index, 1, {
          column: {
            ...defaultActionHeader,
            ...flat[index].column
          },
          row: flat[index].row
        });
    }
    if ((_c = options == null ? void 0 : options.showExpand) == null ? void 0 : _c.value) {
      const index = flat.findIndex((_ref3) => {
        let {
          column
        } = _ref3;
        return column.key === "data-table-expand";
      });
      if (index < 0)
        flat.push({
          column: {
            ...defaultActionHeader,
            key: "data-table-expand",
            rowspan: rowCount
          },
          row: 0
        });
      else
        flat.splice(index, 1, {
          column: {
            ...defaultActionHeader,
            ...flat[index].column
          },
          row: flat[index].row
        });
    }
    const fixedRows = createRange(rowCount).map(() => []);
    const fixedOffsets = createRange(rowCount).fill(0);
    let count = 0;
    flat.forEach((_ref4) => {
      let {
        column,
        row
      } = _ref4;
      const id = column.key ?? `data-table-column-${count++}`;
      for (let i = row; i <= row + (column.rowspan ?? 1) - 1; i++) {
        fixedRows[i].push({
          ...column,
          key: id,
          fixedOffset: fixedOffsets[i],
          sortable: column.sortable ?? !!column.key
        });
        fixedOffsets[i] += column.width ?? 0;
      }
    });
    fixedRows.forEach((row) => {
      for (let i = row.length; i--; i >= 0) {
        if (row[i].fixed) {
          row[i].lastFixed = true;
          return;
        }
      }
    });
    const seen = /* @__PURE__ */ new Set();
    headers.value = fixedRows.map((row) => {
      const filtered = [];
      for (const column of row) {
        if (!seen.has(column.key)) {
          seen.add(column.key);
          filtered.push(column);
        }
      }
      return filtered;
    });
    columns.value = fixedRows.at(-1) ?? [];
  }, {
    deep: true,
    immediate: true
  });
  const data = {
    headers,
    columns
  };
  provide(VDataTableHeadersSymbol, data);
  return data;
}
function useHeaders() {
  const data = inject(VDataTableHeadersSymbol);
  if (!data)
    throw new Error("Missing headers!");
  return data;
}

// node_modules/vuetify/lib/labs/VDataTable/composables/select.mjs
var makeDataTableSelectProps = propsFactory({
  showSelect: Boolean,
  modelValue: {
    type: Array,
    default: () => []
  }
}, "v-data-table-select");
var VDataTableSelectionSymbol = Symbol.for("vuetify:data-table-selection");
function createSelection(props, allItems) {
  const selected = useProxiedModel(props, "modelValue", props.modelValue, (v) => {
    return new Set(v);
  }, (v) => {
    return [...v.values()];
  });
  function isSelected(items) {
    return items.every((item) => selected.value.has(item.value));
  }
  function isSomeSelected(items) {
    return items.some((item) => selected.value.has(item.value));
  }
  function select(items, value) {
    const newSelected = new Set(selected.value);
    for (const item of items) {
      if (value)
        newSelected.add(item.value);
      else
        newSelected.delete(item.value);
    }
    selected.value = newSelected;
  }
  function toggleSelect(item) {
    select([item], !isSelected([item]));
  }
  function selectAll(value) {
    select(allItems.value, value);
  }
  const someSelected = computed(() => selected.value.size > 0);
  const allSelected = computed(() => isSelected(allItems.value));
  const data = {
    toggleSelect,
    select,
    selectAll,
    isSelected,
    isSomeSelected,
    someSelected,
    allSelected
  };
  provide(VDataTableSelectionSymbol, data);
  return data;
}
function useSelection() {
  const data = inject(VDataTableSelectionSymbol);
  if (!data)
    throw new Error("Missing selection!");
  return data;
}

// node_modules/vuetify/lib/labs/VDataTable/composables/sort.mjs
var makeDataTableSortProps = propsFactory({
  sortBy: {
    type: Array,
    default: () => []
  },
  multiSort: Boolean,
  mustSort: Boolean
}, "v-data-table-sort");
var VDataTableSortSymbol = Symbol.for("vuetify:data-table-sort");
function createSort(props) {
  const sortBy = useProxiedModel(props, "sortBy");
  const toggleSort = (key) => {
    let newSortBy = sortBy.value.map((x) => ({
      ...x
    })) ?? [];
    const item = newSortBy.find((x) => x.key === key);
    if (!item) {
      if (props.multiSort)
        newSortBy = [...newSortBy, {
          key,
          order: "asc"
        }];
      else
        newSortBy = [{
          key,
          order: "asc"
        }];
    } else if (item.order === "desc") {
      if (props.mustSort) {
        item.order = "asc";
      } else {
        newSortBy = newSortBy.filter((x) => x.key !== key);
      }
    } else {
      item.order = "desc";
    }
    sortBy.value = newSortBy;
  };
  const data = {
    sortBy,
    toggleSort
  };
  provide(VDataTableSortSymbol, data);
  return data;
}
function useSort() {
  const data = inject(VDataTableSortSymbol);
  if (!data)
    throw new Error("Missing sort!");
  return data;
}
function useSortedItems(items, sortBy, columns) {
  const customSorters = computed(() => {
    return columns.value.reduce((obj, item) => {
      if (item.sort)
        obj[item.key] = item.sort;
      return obj;
    }, {});
  });
  const sortedItems = computed(() => {
    if (!sortBy.value.length)
      return items.value;
    return sortItems(items.value, sortBy.value, "en", customSorters.value);
  });
  return {
    sortedItems
  };
}
function sortItems(items, sortByItems, locale, customSorters) {
  const stringCollator = new Intl.Collator(locale, {
    sensitivity: "accent",
    usage: "sort"
  });
  return [...items].sort((a, b) => {
    for (let i = 0; i < sortByItems.length; i++) {
      const sortKey = sortByItems[i].key;
      const sortOrder = sortByItems[i].order;
      if (sortOrder === false)
        continue;
      let sortA = getObjectValueByPath(a.raw, sortKey);
      let sortB = getObjectValueByPath(b.raw, sortKey);
      if (sortOrder === "desc") {
        [sortA, sortB] = [sortB, sortA];
      }
      if (customSorters == null ? void 0 : customSorters[sortKey]) {
        const customResult = customSorters[sortKey](sortA, sortB);
        if (!customResult)
          continue;
        return customResult;
      }
      if (sortA == null || sortB == null) {
        continue;
      }
      if (sortA instanceof Date && sortB instanceof Date) {
        return sortA.getTime() - sortB.getTime();
      }
      [sortA, sortB] = [sortA, sortB].map((s) => (s || "").toString().toLocaleLowerCase());
      if (sortA !== sortB) {
        if (!isNaN(sortA) && !isNaN(sortB))
          return Number(sortA) - Number(sortB);
        return stringCollator.compare(sortA, sortB);
      }
    }
    return 0;
  });
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTableHeaders.mjs
var VDataTableHeaders = genericComponent()({
  name: "VDataTableHeaders",
  props: {
    color: String,
    sticky: Boolean,
    multiSort: Boolean,
    sortAscIcon: {
      type: IconValue,
      default: "$sortAsc"
    },
    sortDescIcon: {
      type: IconValue,
      default: "$sortDesc"
    },
    ...makeLoaderProps()
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const {
      toggleSort,
      sortBy
    } = useSort();
    const {
      someSelected,
      allSelected,
      selectAll
    } = useSelection();
    const {
      columns,
      headers
    } = useHeaders();
    const {
      loaderClasses
    } = useLoader(props);
    const getFixedStyles = (column, y) => {
      if (!props.sticky && !column.fixed)
        return null;
      return {
        position: "sticky",
        zIndex: column.fixed ? 4 : props.sticky ? 3 : void 0,
        // TODO: This needs to account for possible previous fixed columns.
        left: column.fixed ? convertToUnit(column.fixedOffset) : void 0,
        // TODO: This needs to account for possible row/colspan of previous columns
        top: props.sticky ? `calc(var(--v-table-header-height) * ${y})` : void 0
      };
    };
    function getSortIcon(id) {
      const item = sortBy.value.find((item2) => item2.key === id);
      if (!item)
        return props.sortAscIcon;
      return item.order === "asc" ? props.sortAscIcon : props.sortDescIcon;
    }
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props, "color");
    const VDataTableHeaderCell = (_ref2) => {
      let {
        column,
        x,
        y
      } = _ref2;
      const isSorted = !!sortBy.value.find((x2) => x2.key === column.key);
      const noPadding = column.key === "data-table-select" || column.key === "data-table-expand";
      return createVNode(VDataTableColumn, {
        "tag": "th",
        "align": column.align,
        "class": ["v-data-table__th", {
          "v-data-table__th--sortable": column.sortable,
          "v-data-table__th--sorted": isSorted
        }, loaderClasses.value],
        "style": {
          width: convertToUnit(column.width),
          minWidth: convertToUnit(column.width),
          ...getFixedStyles(column, y)
        },
        "colspan": column.colspan,
        "rowspan": column.rowspan,
        "onClick": column.sortable ? () => toggleSort(column.key) : void 0,
        "lastFixed": column.lastFixed,
        "noPadding": noPadding
      }, {
        default: () => {
          var _a;
          const slotName = `column.${column.key}`;
          const slotProps = {
            column,
            selectAll
          };
          if (slots[slotName])
            return slots[slotName](slotProps);
          if (column.key === "data-table-select") {
            return ((_a = slots["column.data-table-select"]) == null ? void 0 : _a.call(slots, slotProps)) ?? createVNode(VCheckboxBtn, {
              "modelValue": allSelected.value,
              "indeterminate": someSelected.value && !allSelected.value,
              "onUpdate:modelValue": selectAll
            }, null);
          }
          return createVNode("div", {
            "class": "v-data-table-header__content"
          }, [createVNode("span", null, [column.title]), column.sortable && createVNode(VIcon, {
            "key": "icon",
            "class": "v-data-table-header__sort-icon",
            "icon": getSortIcon(column.key)
          }, null), props.multiSort && isSorted && createVNode("div", {
            "key": "badge",
            "class": ["v-data-table-header__sort-badge", ...backgroundColorClasses.value],
            "style": backgroundColorStyles.value
          }, [sortBy.value.findIndex((x2) => x2.key === column.key) + 1])]);
        }
      });
    };
    useRender(() => createVNode(Fragment, null, [headers.value.map((row, y) => createVNode("tr", null, [row.map((column, x) => createVNode(VDataTableHeaderCell, {
      "column": column,
      "x": x,
      "y": y
    }, null))])), props.loading && createVNode("tr", {
      "class": "v-data-table__progress"
    }, [createVNode("th", {
      "colspan": columns.value.length
    }, [createVNode(LoaderSlot, {
      "name": "v-data-table-headers",
      "active": true,
      "color": typeof props.loading === "boolean" ? void 0 : props.loading,
      "indeterminate": true
    }, {
      default: slots.loader
    })])])]));
  }
});

// node_modules/vuetify/lib/labs/VDataTable/composables/group.mjs
var makeDataTableGroupProps = propsFactory({
  groupBy: {
    type: Array,
    default: () => []
  }
}, "data-table-group");
var VDataTableGroupSymbol = Symbol.for("vuetify:data-table-group");
function createGroupBy(props, groupBy, sortBy) {
  const opened = ref(/* @__PURE__ */ new Set());
  const sortByWithGroups = computed(() => {
    return groupBy.value.map((val) => ({
      ...val,
      order: val.order ?? false
    })).concat(sortBy.value);
  });
  function isGroupOpen(group) {
    return opened.value.has(group.id);
  }
  function toggleGroup(group) {
    const newOpened = new Set(opened.value);
    if (!isGroupOpen(group))
      newOpened.add(group.id);
    else
      newOpened.delete(group.id);
    opened.value = newOpened;
  }
  function extractRows(items) {
    function dive(group) {
      const arr = [];
      for (const item of group.items) {
        if (item.type === "item")
          arr.push(item);
        else {
          arr.push(...dive(item));
        }
      }
      return arr;
    }
    return dive({
      type: "group-header",
      items,
      id: "dummy",
      key: "dummy",
      value: "dummy",
      depth: 0
    });
  }
  const data = {
    sortByWithGroups,
    toggleGroup,
    opened,
    groupBy,
    extractRows,
    isGroupOpen
  };
  provide(VDataTableGroupSymbol, data);
  return data;
}
function useGroupBy() {
  const data = inject(VDataTableGroupSymbol);
  if (!data)
    throw new Error("Missing group!");
  return data;
}
function groupItemsByProperty(items, groupBy) {
  if (!items.length)
    return [];
  const groups = /* @__PURE__ */ new Map();
  for (const item of items) {
    const value = getObjectValueByPath(item.raw, groupBy);
    if (!groups.has(value)) {
      groups.set(value, []);
    }
    groups.get(value).push(item);
  }
  return groups;
}
function groupItems(items, groupBy) {
  let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  let prefix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
  if (!groupBy.length)
    return [];
  const groupedItems = groupItemsByProperty(items, groupBy[0]);
  const groups = [];
  const rest = groupBy.slice(1);
  groupedItems.forEach((items2, value) => {
    const key = groupBy[0];
    const id = `${prefix}_${key}_${value}`;
    groups.push({
      depth,
      id,
      key,
      value,
      items: rest.length ? groupItems(items2, rest, depth + 1, id) : items2,
      type: "group-header"
    });
  });
  return groups;
}
function flattenItems(items, opened) {
  const flatItems = [];
  for (const item of items) {
    if (item.type === "group-header") {
      if (item.value != null) {
        flatItems.push(item);
      }
      if (opened.has(item.id) || item.value == null) {
        flatItems.push(...flattenItems(item.items, opened));
      }
    } else {
      flatItems.push(item);
    }
  }
  return flatItems;
}
function useGroupedItems(items, groupBy, opened) {
  const flatItems = computed(() => {
    if (!groupBy.value.length)
      return items.value;
    const groupedItems = groupItems(items.value, groupBy.value.map((item) => item.key));
    return flattenItems(groupedItems, opened.value);
  });
  return {
    flatItems
  };
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTableGroupHeaderRow.mjs
var VDataTableGroupHeaderRow = genericComponent()({
  name: "VDataTableGroupHeaderRow",
  props: {
    item: {
      type: Object,
      required: true
    }
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      isGroupOpen,
      toggleGroup,
      extractRows
    } = useGroupBy();
    const {
      isSelected,
      isSomeSelected,
      select
    } = useSelection();
    const {
      columns
    } = useHeaders();
    const rows = computed(() => {
      return extractRows([props.item]);
    });
    return () => createVNode("tr", {
      "class": "v-data-table-group-header-row",
      "style": {
        "--v-data-table-group-header-row-depth": props.item.depth
      }
    }, [columns.value.map((column) => {
      var _a, _b;
      if (column.key === "data-table-group") {
        const icon = isGroupOpen(props.item) ? "$expand" : "$next";
        const onClick = () => toggleGroup(props.item);
        return ((_a = slots["data-table-group"]) == null ? void 0 : _a.call(slots, {
          item: props.item,
          count: rows.value.length,
          props: {
            icon,
            onClick
          }
        })) ?? createVNode(VDataTableColumn, {
          "class": "v-data-table-group-header-row__column"
        }, {
          default: () => [createVNode(VBtn, {
            "size": "small",
            "variant": "text",
            "icon": icon,
            "onClick": onClick
          }, null), createVNode("span", null, [props.item.value]), createVNode("span", null, [createTextVNode("("), rows.value.length, createTextVNode(")")])]
        });
      }
      if (column.key === "data-table-select") {
        const modelValue = isSelected(rows.value);
        const indeterminate = isSomeSelected(rows.value) && !modelValue;
        const selectGroup = (v) => select(rows.value, v);
        return ((_b = slots["data-table-select"]) == null ? void 0 : _b.call(slots, {
          props: {
            modelValue,
            indeterminate,
            "onUpdate:modelValue": selectGroup
          }
        })) ?? createVNode("td", null, [createVNode(VCheckboxBtn, {
          "modelValue": modelValue,
          "indeterminate": indeterminate,
          "onUpdate:modelValue": selectGroup
        }, null)]);
      }
      return createVNode("td", null, null);
    })]);
  }
});

// node_modules/vuetify/lib/labs/VDataTable/composables/expand.mjs
var makeDataTableExpandProps = propsFactory({
  expandOnClick: Boolean,
  showExpand: Boolean,
  expanded: {
    type: Array,
    default: () => []
  }
}, "v-data-table-expand");
var VDataTableExpandedKey = Symbol.for("vuetify:datatable:expanded");
function createExpanded(props) {
  const expandOnClick = toRef(props, "expandOnClick");
  const expanded = useProxiedModel(props, "expanded", props.expanded, (v) => {
    return new Set(v);
  }, (v) => {
    return [...v.values()];
  });
  function expand(item, value) {
    const newExpanded = new Set(expanded.value);
    if (!value) {
      newExpanded.delete(item.value);
    } else {
      newExpanded.add(item.value);
    }
    expanded.value = newExpanded;
  }
  function isExpanded(item) {
    return expanded.value.has(item.value);
  }
  function toggleExpand(item) {
    expand(item, !isExpanded(item));
  }
  const data = {
    expand,
    expanded,
    expandOnClick,
    isExpanded,
    toggleExpand
  };
  provide(VDataTableExpandedKey, data);
  return data;
}
function useExpanded() {
  const data = inject(VDataTableExpandedKey);
  if (!data)
    throw new Error("foo");
  return data;
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTableRow.mjs
var VDataTableRow = defineComponent({
  name: "VDataTableRow",
  props: {
    item: Object
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      isSelected,
      toggleSelect
    } = useSelection();
    const {
      isExpanded,
      toggleExpand
    } = useExpanded();
    const {
      columns
    } = useHeaders();
    useRender(() => createVNode("tr", {
      "class": ["v-data-table__tr"]
    }, [!columns.value.length && createVNode(VDataTableColumn, {
      "key": "no-data"
    }, slots), props.item && columns.value.map((column, i) => createVNode(VDataTableColumn, {
      "align": column.align,
      "fixed": column.fixed,
      "fixedOffset": column.fixedOffset,
      "lastFixed": column.lastFixed,
      "noPadding": column.key === "data-table-select" || column.key === "data-table-expand",
      "width": column.width
    }, {
      default: () => {
        var _a, _b;
        const item = props.item;
        const slotName = `item.${column.key}`;
        const slotProps = {
          item: props.item,
          columns: columns.value,
          isSelected,
          toggleSelect,
          isExpanded,
          toggleExpand
        };
        if (slots[slotName])
          return slots[slotName](slotProps);
        if (column.key === "data-table-select") {
          return ((_a = slots["item.data-table-select"]) == null ? void 0 : _a.call(slots, slotProps)) ?? createVNode(VCheckboxBtn, {
            "modelValue": isSelected([item]),
            "onClick": () => toggleSelect(item)
          }, null);
        }
        if (column.key === "data-table-expand") {
          return ((_b = slots["item.data-table-expand"]) == null ? void 0 : _b.call(slots, slotProps)) ?? createVNode(VBtn, {
            "icon": isExpanded(item) ? "$collapse" : "$expand",
            "size": "small",
            "variant": "text",
            "onClick": () => toggleExpand(item)
          }, null);
        }
        return item.columns[column.key];
      }
    }))]));
  }
});

// node_modules/vuetify/lib/labs/VDataTable/VDataTableRows.mjs
var VDataTableRows = genericComponent()({
  name: "VDataTableRows",
  props: {
    loading: [Boolean, String],
    loadingText: {
      type: String,
      default: "$vuetify.dataIterator.loadingText"
    },
    hideNoData: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    noDataText: {
      type: String,
      default: "$vuetify.noDataText"
    },
    rowHeight: Number
  },
  emits: {
    "click:row": (event, value) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      columns
    } = useHeaders();
    const {
      expandOnClick,
      toggleExpand,
      isExpanded
    } = useExpanded();
    const {
      isSelected,
      toggleSelect
    } = useSelection();
    const {
      toggleGroup,
      isGroupOpen
    } = useGroupBy();
    const {
      t
    } = useLocale();
    useRender(() => {
      var _a, _b;
      return createVNode(Fragment, null, [props.loading ? ((_a = slots.loading) == null ? void 0 : _a.call(slots)) ?? createVNode(VDataTableRow, {
        "class": "v-data-table-rows-no-data",
        "key": "loading"
      }, {
        default: () => [t(props.loadingText)]
      }) : void 0, !props.loading && !props.items.length && !props.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VDataTableRow, {
        "class": "v-data-table-rows-no-data",
        "key": "no-data"
      }, {
        default: () => [t(props.noDataText)]
      })), props.items.map((item, index) => {
        var _a2;
        if (item.type === "group-header") {
          return slots["group-header"] ? slots["group-header"]({
            index,
            item,
            columns: columns.value,
            isExpanded,
            toggleExpand,
            isSelected,
            toggleSelect,
            toggleGroup,
            isGroupOpen
          }) : createVNode(VDataTableGroupHeaderRow, {
            "key": `group-header_${item.id}`,
            "item": item
          }, slots);
        }
        return createVNode(Fragment, null, [slots.item ? slots.item({
          index,
          item,
          columns: columns.value,
          isExpanded,
          toggleExpand,
          isSelected,
          toggleSelect
        }) : createVNode(VDataTableRow, {
          "key": `item_${item.value}`,
          "onClick": (event) => {
            if (expandOnClick.value) {
              toggleExpand(item.value);
            }
            emit("click:row", event, {
              item
            });
          },
          "item": item
        }, slots), isExpanded(item) && ((_a2 = slots["expanded-row"]) == null ? void 0 : _a2.call(slots, {
          item,
          columns: columns.value
        }))]);
      })]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VDataTable/VDataTableFooter.mjs
import "C:/xampp/htdocs/sappat/sAPPat_v2_vue/node_modules/vuetify/lib/labs/VDataTable/VDataTableFooter.css";

// node_modules/vuetify/lib/labs/VDataTable/composables/paginate.mjs
var makeDataTablePaginateProps = propsFactory({
  page: {
    type: [Number, String],
    default: 1
  },
  itemsPerPage: {
    type: [Number, String],
    default: 10
  }
}, "v-data-table-paginate");
var VDataTablePaginationSymbol = Symbol.for("vuetify:data-table-pagination");
function createPagination(props, items) {
  const page = useProxiedModel(props, "page", void 0, (value) => +(value ?? 1));
  const itemsPerPage = useProxiedModel(props, "itemsPerPage", void 0, (value) => +(value ?? 10));
  const itemsLength = computed(() => +(props.itemsLength ?? items.value.length));
  const startIndex = computed(() => {
    if (itemsPerPage.value === -1)
      return 0;
    return itemsPerPage.value * (page.value - 1);
  });
  const stopIndex = computed(() => {
    if (itemsPerPage.value === -1)
      return itemsLength.value;
    return Math.min(itemsLength.value, startIndex.value + itemsPerPage.value);
  });
  const pageCount = computed(() => {
    if (itemsPerPage.value === -1 || itemsLength.value === 0)
      return 1;
    return Math.ceil(itemsLength.value / itemsPerPage.value);
  });
  const data = {
    page,
    itemsPerPage,
    startIndex,
    stopIndex,
    pageCount,
    itemsLength
  };
  provide(VDataTablePaginationSymbol, data);
  return data;
}
function usePagination() {
  const data = inject(VDataTablePaginationSymbol);
  if (!data)
    throw new Error("Missing pagination!");
  return data;
}
function usePaginatedItems(items, startIndex, stopIndex, itemsPerPage) {
  const paginatedItems = computed(() => {
    if (itemsPerPage.value <= 0)
      return items.value;
    return items.value.slice(startIndex.value, stopIndex.value);
  });
  return {
    paginatedItems
  };
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTableFooter.mjs
var VDataTableFooter = genericComponent()({
  name: "VDataTableFooter",
  props: {
    prevIcon: {
      type: String,
      default: "$prev"
    },
    nextIcon: {
      type: String,
      default: "$next"
    },
    firstIcon: {
      type: String,
      default: "$first"
    },
    lastIcon: {
      type: String,
      default: "$last"
    },
    itemsPerPageText: {
      type: String,
      default: "$vuetify.dataFooter.itemsPerPageText"
    },
    pageText: {
      type: String,
      default: "$vuetify.dataFooter.pageText"
    },
    firstPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.firstPage"
    },
    prevPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.prevPage"
    },
    nextPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.nextPage"
    },
    lastPageLabel: {
      type: String,
      default: "$vuetify.dataFooter.lastPage"
    },
    itemsPerPageOptions: {
      type: Array,
      default: () => [{
        value: 10,
        title: "10"
      }, {
        value: 25,
        title: "25"
      }, {
        value: 50,
        title: "50"
      }, {
        value: 100,
        title: "100"
      }, {
        value: -1,
        title: "$vuetify.dataFooter.itemsPerPageAll"
      }]
    },
    showCurrentPage: Boolean
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const {
      page,
      pageCount,
      startIndex,
      stopIndex,
      itemsLength,
      itemsPerPage
    } = usePagination();
    const itemsPerPageOptions = computed(() => props.itemsPerPageOptions.map((option) => ({
      ...option,
      title: t(option.title)
    })));
    return () => {
      var _a;
      return createVNode("div", {
        "class": "v-data-table-footer"
      }, [(_a = slots.prepend) == null ? void 0 : _a.call(slots), createVNode("div", {
        "class": "v-data-table-footer__items-per-page"
      }, [createVNode("span", null, [t(props.itemsPerPageText)]), createVNode(VSelect, {
        "items": itemsPerPageOptions.value,
        "modelValue": itemsPerPage.value,
        "onUpdate:modelValue": (v) => itemsPerPage.value = Number(v),
        "density": "compact",
        "variant": "outlined",
        "hide-details": true
      }, null)]), createVNode("div", {
        "class": "v-data-table-footer__info"
      }, [createVNode("div", null, [t(props.pageText, !itemsLength.value ? 0 : startIndex.value + 1, stopIndex.value, itemsLength.value)])]), createVNode("div", {
        "class": "v-data-table-footer__pagination"
      }, [createVNode(VBtn, {
        "icon": props.firstIcon,
        "variant": "plain",
        "onClick": () => page.value = 1,
        "disabled": page.value === 1,
        "aria-label": t(props.firstPageLabel)
      }, null), createVNode(VBtn, {
        "icon": props.prevIcon,
        "variant": "plain",
        "onClick": () => page.value = Math.max(1, page.value - 1),
        "disabled": page.value === 1,
        "aria-label": t(props.prevPageLabel)
      }, null), props.showCurrentPage && createVNode("span", {
        "key": "page",
        "class": "v-data-table-footer__page"
      }, [page.value]), createVNode(VBtn, {
        "icon": props.nextIcon,
        "variant": "plain",
        "onClick": () => page.value = Math.min(pageCount.value, page.value + 1),
        "disabled": page.value === pageCount.value,
        "aria-label": t(props.nextPageLabel)
      }, null), createVNode(VBtn, {
        "icon": props.lastIcon,
        "variant": "plain",
        "onClick": () => page.value = pageCount.value,
        "disabled": page.value === pageCount.value,
        "aria-label": t(props.lastPageLabel)
      }, null)])]);
    };
  }
});

// node_modules/vuetify/lib/labs/VDataTable/composables/items.mjs
var makeDataTableItemProps = propsFactory({
  // TODO: Worth it to make specific datatable implementation
  // without title, children?
  ...makeItemsProps({
    itemValue: "id"
  })
}, "v-data-table-item");
function useDataTableItems(props, columns) {
  const {
    items
  } = useItems(props);
  const dataTableItems = computed(() => items.value.map((item) => {
    return {
      ...item,
      type: "item",
      columns: columns.value.reduce((obj, column) => {
        obj[column.key] = getPropertyFromItem(item.raw, column.value ?? column.key);
        return obj;
      }, {})
    };
  }));
  return {
    items: dataTableItems
  };
}

// node_modules/vuetify/lib/labs/VDataTable/composables/options.mjs
function useOptions(_ref) {
  let {
    page,
    itemsPerPage,
    sortBy,
    groupBy
  } = _ref;
  const vm = getCurrentInstance("VDataTable");
  const options = computed(() => ({
    page: page.value,
    itemsPerPage: itemsPerPage.value,
    sortBy: sortBy.value,
    groupBy: groupBy.value
  }));
  watch(sortBy, () => {
    page.value = 1;
  }, {
    deep: true
  });
  watch(itemsPerPage, () => {
    page.value = 1;
  });
  let oldOptions = null;
  watch(options, () => {
    if (deepEqual(oldOptions, options.value))
      return;
    vm.emit("update:options", options.value);
    oldOptions = options.value;
  }, {
    deep: true,
    immediate: true
  });
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTable.mjs
var makeVDataTableProps = propsFactory({
  ...makeDataTableItemProps(),
  ...makeDataTableHeaderProps(),
  hideNoData: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  height: [String, Number],
  width: [String, Number],
  fixedHeader: Boolean,
  fixedFooter: Boolean
}, "v-data-table");
var VDataTable = genericComponent()({
  name: "VDataTable",
  props: {
    search: String,
    ...makeVDataTableProps(),
    ...makeDataTableExpandProps(),
    ...makeDataTableGroupProps(),
    ...makeDataTableSelectProps(),
    ...makeDataTableSortProps(),
    ...makeDataTablePaginateProps(),
    ...makeFilterProps()
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:page": (value) => true,
    "update:itemsPerPage": (value) => true,
    "update:sortBy": (value) => true,
    "update:options": (value) => true,
    "update:groupBy": (value) => true,
    "update:expanded": (value) => true,
    "click:row": (event, value) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const groupBy = useProxiedModel(props, "groupBy");
    const {
      columns
    } = createHeaders(props, {
      groupBy,
      showSelect: toRef(props, "showSelect"),
      showExpand: toRef(props, "showExpand")
    });
    const {
      items
    } = useDataTableItems(props, columns);
    const filterKeys = computed(() => columns.value.map((c) => "columns." + c.key));
    const {
      filteredItems
    } = useFilter(props, items, toRef(props, "search"), {
      filterKeys
    });
    const {
      sortBy
    } = createSort(props);
    const {
      sortByWithGroups,
      opened,
      extractRows
    } = createGroupBy(props, groupBy, sortBy);
    const {
      sortedItems
    } = useSortedItems(filteredItems, sortByWithGroups, columns);
    const {
      flatItems
    } = useGroupedItems(sortedItems, groupBy, opened);
    const {
      page,
      itemsPerPage,
      startIndex,
      stopIndex
    } = createPagination(props, flatItems);
    const {
      paginatedItems
    } = usePaginatedItems(flatItems, startIndex, stopIndex, itemsPerPage);
    const paginatedItemsWithoutGroups = computed(() => extractRows(paginatedItems.value));
    createSelection(props, paginatedItemsWithoutGroups);
    createExpanded(props);
    useOptions({
      page,
      itemsPerPage,
      sortBy,
      groupBy
    });
    provideDefaults({
      VDataTableRows: {
        hideNoData: toRef(props, "hideNoData"),
        noDataText: toRef(props, "noDataText")
      }
    });
    useRender(() => createVNode(VTable, {
      "class": ["v-data-table", {
        "v-data-table--show-select": props.showSelect
      }],
      "fixedHeader": props.fixedHeader,
      "fixedFooter": props.fixedFooter,
      "height": props.height
    }, {
      top: slots.top,
      default: slots.default ?? (() => {
        var _a, _b, _c, _d;
        return createVNode(Fragment, null, [(_a = slots.colgroup) == null ? void 0 : _a.call(slots, {
          columns
        }), createVNode("thead", null, [slots.headers ? slots.headers() : createVNode(VDataTableHeaders, {
          "sticky": props.fixedHeader,
          "multiSort": props.multiSort
        }, slots)]), (_b = slots.thead) == null ? void 0 : _b.call(slots), createVNode("tbody", null, [slots.body ? slots.body() : createVNode(VDataTableRows, {
          "items": paginatedItems.value,
          "onClick:row": (event, value) => emit("click:row", event, value)
        }, slots)]), (_c = slots.tbody) == null ? void 0 : _c.call(slots), (_d = slots.tfoot) == null ? void 0 : _d.call(slots)]);
      }),
      bottom: slots.bottom ?? (() => createVNode(VDataTableFooter, null, {
        prepend: slots["footer.prepend"]
      }))
    }));
    return {};
  }
});

// node_modules/vuetify/lib/labs/VDataTable/composables/virtual.mjs
var makeDataTableVirtualProps = propsFactory({
  visibleItems: {
    type: [String, Number],
    default: 20
  },
  itemHeight: {
    type: [String, Number],
    default: 52
  }
}, "virtual");
var UP = -1;
var DOWN = 1;
function useVirtual(props, items) {
  const startIndex = ref(0);
  const itemHeight = computed(() => parseInt(props.itemHeight, 10));
  const visibleItems = computed(() => parseInt(props.visibleItems, 10));
  const containerRef = ref();
  const isScrolling = ref(false);
  function calculateOffset(index) {
    return index * itemHeight.value;
  }
  function calculateMidPointIndex(scrollTop) {
    let start = 0;
    let end = items.value.length;
    while (start <= end) {
      const middle = start + Math.floor((end - start) / 2);
      const middleOffset = calculateOffset(middle);
      if (middleOffset === scrollTop) {
        return middle;
      } else if (middleOffset < scrollTop) {
        start = middle + 1;
      } else if (middleOffset > scrollTop) {
        end = middle - 1;
      }
    }
    return start;
  }
  let lastScrollTop = 0;
  let scrollTimeout;
  function handleScroll() {
    if (!containerRef.value)
      return;
    isScrolling.value = true;
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
      isScrolling.value = false;
    }, 100);
    const scrollTop = containerRef.value.scrollTop;
    const direction = scrollTop < lastScrollTop ? UP : DOWN;
    const midPointIndex = calculateMidPointIndex(scrollTop);
    const buffer = Math.round(visibleItems.value / 3);
    if (direction === UP && midPointIndex <= startIndex.value) {
      startIndex.value = Math.max(midPointIndex - buffer, 0);
    } else if (direction === DOWN && midPointIndex >= startIndex.value + buffer * 2) {
      startIndex.value = Math.min(Math.max(0, midPointIndex - buffer), items.value.length - visibleItems.value);
    }
    lastScrollTop = containerRef.value.scrollTop;
  }
  const stopIndex = computed(() => Math.min(items.value.length, startIndex.value + visibleItems.value));
  const paddingTop = computed(() => calculateOffset(startIndex.value));
  const paddingBottom = computed(() => calculateOffset(items.value.length) - calculateOffset(stopIndex.value));
  return {
    startIndex,
    stopIndex,
    paddingTop,
    paddingBottom,
    handleScroll,
    containerRef,
    itemHeight,
    isScrolling
  };
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTableVirtual.mjs
var VDataTableVirtual = genericComponent()({
  name: "VDataTableVirtual",
  props: {
    search: String,
    ...makeVDataTableProps(),
    ...makeVDataTableProps(),
    ...makeDataTableGroupProps(),
    ...makeDataTableExpandProps(),
    ...makeDataTableHeaderProps(),
    ...makeDataTableItemProps(),
    ...makeDataTableSelectProps(),
    ...makeDataTableSortProps(),
    ...makeDataTableVirtualProps(),
    ...makeFilterProps()
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:sortBy": (value) => true,
    "update:options": (value) => true,
    "update:groupBy": (value) => true,
    "update:expanded": (value) => true,
    "click:row": (event, value) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const groupBy = useProxiedModel(props, "groupBy");
    const {
      columns
    } = createHeaders(props, {
      groupBy,
      showSelect: toRef(props, "showSelect"),
      showExpand: toRef(props, "showExpand")
    });
    const {
      items
    } = useDataTableItems(props, columns);
    const filterKeys = computed(() => columns.value.map((c) => "columns." + c.key));
    const {
      filteredItems
    } = useFilter(props, items, toRef(props, "search"), {
      filterKeys
    });
    const {
      sortBy
    } = createSort(props);
    const {
      sortByWithGroups,
      opened,
      extractRows
    } = createGroupBy(props, groupBy, sortBy);
    const {
      sortedItems
    } = useSortedItems(filteredItems, sortByWithGroups, columns);
    const {
      flatItems
    } = useGroupedItems(sortedItems, groupBy, opened);
    const allRows = computed(() => extractRows(flatItems.value));
    createSelection(props, allRows);
    createExpanded(props);
    const {
      containerRef,
      paddingTop,
      paddingBottom,
      startIndex,
      stopIndex,
      itemHeight,
      handleScroll
    } = useVirtual(props, flatItems);
    const visibleItems = computed(() => {
      return flatItems.value.slice(startIndex.value, stopIndex.value);
    });
    useOptions({
      sortBy,
      page: ref(1),
      itemsPerPage: ref(-1),
      groupBy
    });
    provideDefaults({
      VDataTableRows: {
        hideNoData: toRef(props, "hideNoData"),
        noDataText: toRef(props, "noDataText")
      }
    });
    useRender(() => createVNode(VTable, {
      "class": "v-data-table",
      "style": {
        "--v-table-row-height": convertToUnit(itemHeight.value)
      },
      "height": props.height,
      "fixedHeader": props.fixedHeader
    }, {
      top: slots.top,
      wrapper: () => createVNode("div", {
        "ref": containerRef,
        "onScroll": handleScroll,
        "class": "v-table__wrapper",
        "style": {
          height: convertToUnit(props.height)
        }
      }, [createVNode("table", null, [createVNode("thead", null, [createVNode(VDataTableHeaders, {
        "sticky": props.fixedHeader,
        "multiSort": props.multiSort
      }, slots)]), createVNode("tbody", null, [createVNode("tr", {
        "style": {
          height: convertToUnit(paddingTop.value),
          border: 0
        }
      }, [createVNode("td", {
        "colspan": columns.value.length,
        "style": {
          height: convertToUnit(paddingTop.value),
          border: 0
        }
      }, null)]), createVNode(VDataTableRows, {
        "items": visibleItems.value,
        "onClick:row": (event, value) => emit("click:row", event, value)
      }, slots), createVNode("tr", {
        "style": {
          height: convertToUnit(paddingBottom.value),
          border: 0
        }
      }, [createVNode("td", {
        "colspan": columns.value.length,
        "style": {
          height: convertToUnit(paddingBottom.value),
          border: 0
        }
      }, null)])])])]),
      bottom: slots.bottom
    }));
  }
});

// node_modules/vuetify/lib/labs/VDataTable/VDataTableServer.mjs
var VDataTableServer = genericComponent()({
  name: "VDataTableServer",
  props: {
    color: String,
    loading: [Boolean, String],
    loadingText: {
      type: String,
      default: "$vuetify.dataIterator.loadingText"
    },
    itemsLength: [Number, String],
    ...makeVDataTableProps(),
    ...makeDataTableExpandProps(),
    ...makeDataTableHeaderProps(),
    ...makeDataTableItemProps(),
    ...makeDataTableSelectProps(),
    ...makeDataTableSortProps(),
    ...makeDataTablePaginateProps(),
    ...makeDataTableGroupProps()
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:page": (page) => true,
    "update:itemsPerPage": (page) => true,
    "update:sortBy": (sortBy) => true,
    "update:options": (options) => true,
    "update:expanded": (options) => true,
    "update:groupBy": (value) => true,
    "click:row": (event, value) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const groupBy = useProxiedModel(props, "groupBy");
    createExpanded(props);
    const {
      columns
    } = createHeaders(props, {
      groupBy,
      showSelect: toRef(props, "showSelect"),
      showExpand: toRef(props, "showExpand")
    });
    const {
      items
    } = useDataTableItems(props, columns);
    const {
      sortBy,
      toggleSort
    } = createSort(props);
    const {
      opened
    } = createGroupBy(props, groupBy, sortBy);
    const {
      page,
      itemsPerPage
    } = createPagination(props, items);
    const {
      flatItems
    } = useGroupedItems(items, groupBy, opened);
    createSelection(props, items);
    useOptions({
      page,
      itemsPerPage,
      sortBy,
      groupBy
    });
    provide("v-data-table", {
      toggleSort,
      sortBy
    });
    provideDefaults({
      VDataTableRows: {
        hideNoData: toRef(props, "hideNoData"),
        noDataText: toRef(props, "noDataText"),
        loading: toRef(props, "loading"),
        loadingText: toRef(props, "loadingText")
      }
    });
    useRender(() => createVNode(VTable, {
      "class": ["v-data-table", {
        "v-data-table--loading": props.loading
      }],
      "fixedHeader": props.fixedHeader,
      "fixedFooter": props.fixedFooter,
      "height": props.height
    }, {
      top: slots.top,
      default: slots.default ?? (() => {
        var _a, _b, _c;
        return createVNode(Fragment, null, [createVNode("thead", {
          "class": "v-data-table__thead",
          "role": "rowgroup"
        }, [slots.headers ? slots.headers() : createVNode(VDataTableHeaders, {
          "sticky": props.fixedHeader,
          "loading": props.loading,
          "color": props.color
        }, slots)]), (_a = slots.thead) == null ? void 0 : _a.call(slots), createVNode("tbody", {
          "class": "v-data-table__tbody",
          "role": "rowgroup"
        }, [slots.body ? slots.body() : createVNode(VDataTableRows, {
          "items": flatItems.value,
          "onClick:row": (event, value) => emit("click:row", event, value)
        }, slots)]), (_b = slots.tbody) == null ? void 0 : _b.call(slots), (_c = slots.tfoot) == null ? void 0 : _c.call(slots)]);
      }),
      bottom: slots.bottom ?? (() => createVNode(VDataTableFooter, null, {
        prepend: slots["footer.prepend"]
      }))
    }));
  }
});

// node_modules/vuetify/lib/labs/VVirtualScroll/VVirtualScroll.mjs
import "C:/xampp/htdocs/sappat/sAPPat_v2_vue/node_modules/vuetify/lib/labs/VVirtualScroll/VVirtualScroll.css";

// node_modules/vuetify/lib/labs/VVirtualScroll/VVirtualScrollItem.mjs
var VVirtualScrollItem = genericComponent()({
  name: "VVirtualScrollItem",
  props: {
    dynamicHeight: Boolean
  },
  emits: {
    "update:height": (height) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    useToggleScope(() => props.dynamicHeight, () => {
      watch(() => {
        var _a;
        return (_a = contentRect.value) == null ? void 0 : _a.height;
      }, (height) => {
        if (height != null)
          emit("update:height", height);
      });
    });
    function updateHeight() {
      if (props.dynamicHeight && contentRect.value) {
        emit("update:height", contentRect.value.height);
      }
    }
    onUpdated(updateHeight);
    useRender(() => {
      var _a;
      return createVNode("div", {
        "ref": props.dynamicHeight ? resizeRef : void 0,
        "class": "v-virtual-scroll__item"
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    });
  }
});

// node_modules/vuetify/lib/labs/VVirtualScroll/VVirtualScroll.mjs
var UP2 = -1;
var DOWN2 = 1;
var VVirtualScroll = genericComponent()({
  name: "VVirtualScroll",
  props: {
    items: {
      type: Array,
      default: () => []
    },
    itemHeight: [Number, String],
    visibleItems: [Number, String],
    ...makeDimensionProps()
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const first = ref(0);
    const baseItemHeight = ref(props.itemHeight);
    const itemHeight = computed({
      get: () => parseInt(baseItemHeight.value ?? 0, 10),
      set(val) {
        baseItemHeight.value = val;
      }
    });
    const rootEl = ref();
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    watchEffect(() => {
      resizeRef.value = rootEl.value;
    });
    const display = useDisplay();
    const sizes = createRange(props.items.length).map(() => itemHeight.value);
    const visibleItems = computed(() => {
      var _a;
      return props.visibleItems ? parseInt(props.visibleItems, 10) : Math.max(12, Math.ceil((((_a = contentRect.value) == null ? void 0 : _a.height) ?? display.height.value) / itemHeight.value * 1.7 + 1));
    });
    function handleItemResize(index, height) {
      itemHeight.value = Math.max(itemHeight.value, height);
      sizes[index] = height;
    }
    function calculateOffset(index) {
      return sizes.slice(0, index).reduce((curr, value) => curr + (value || itemHeight.value), 0);
    }
    function calculateMidPointIndex(scrollTop) {
      let start = 0;
      let end = props.items.length;
      while (start <= end) {
        const middle = start + Math.floor((end - start) / 2);
        const middleOffset = calculateOffset(middle);
        if (middleOffset === scrollTop) {
          return middle;
        } else if (middleOffset < scrollTop) {
          start = middle + 1;
        } else if (middleOffset > scrollTop) {
          end = middle - 1;
        }
      }
      return start;
    }
    let lastScrollTop = 0;
    function handleScroll() {
      if (!rootEl.value || !contentRect.value)
        return;
      const height = contentRect.value.height;
      const scrollTop = rootEl.value.scrollTop;
      const direction = scrollTop < lastScrollTop ? UP2 : DOWN2;
      const midPointIndex = calculateMidPointIndex(scrollTop + height / 2);
      const buffer = Math.round(visibleItems.value / 3);
      if (direction === UP2 && midPointIndex <= first.value + buffer * 2 - 1) {
        first.value = clamp(midPointIndex - buffer, 0, props.items.length);
      } else if (direction === DOWN2 && midPointIndex >= first.value + buffer * 2 - 1) {
        first.value = clamp(midPointIndex - buffer, 0, props.items.length - visibleItems.value);
      }
      lastScrollTop = rootEl.value.scrollTop;
    }
    function scrollToIndex(index) {
      if (!rootEl.value)
        return;
      const offset = calculateOffset(index);
      rootEl.value.scrollTop = offset;
    }
    const last = computed(() => Math.min(props.items.length, first.value + visibleItems.value));
    const computedItems = computed(() => props.items.slice(first.value, last.value));
    const paddingTop = computed(() => calculateOffset(first.value));
    const paddingBottom = computed(() => calculateOffset(props.items.length) - calculateOffset(last.value));
    const {
      dimensionStyles
    } = useDimension(props);
    onMounted(() => {
      if (!itemHeight.value) {
        itemHeight.value = sizes.slice(first.value, last.value).reduce((curr, height) => curr + height, 0) / visibleItems.value;
      }
    });
    useRender(() => createVNode("div", {
      "ref": rootEl,
      "class": "v-virtual-scroll",
      "onScroll": handleScroll,
      "style": dimensionStyles.value
    }, [createVNode("div", {
      "class": "v-virtual-scroll__container",
      "style": {
        paddingTop: convertToUnit(paddingTop.value),
        paddingBottom: convertToUnit(paddingBottom.value)
      }
    }, [computedItems.value.map((item, index) => createVNode(VVirtualScrollItem, {
      "key": index,
      "dynamicHeight": !props.itemHeight,
      "onUpdate:height": (height) => handleItemResize(index + first.value, height)
    }, {
      default: () => {
        var _a;
        return [(_a = slots.default) == null ? void 0 : _a.call(slots, {
          item,
          index: index + first.value
        })];
      }
    }))])]));
    return {
      scrollToIndex
    };
  }
});
export {
  VDataTable,
  VDataTableFooter,
  VDataTableRow,
  VDataTableRows,
  VDataTableServer,
  VDataTableVirtual,
  VVirtualScroll
};
//# sourceMappingURL=vuetify_labs_components.js.map
